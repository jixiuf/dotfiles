* xorg or wayland
/etc/gdm3/custom.conf
WaylandEnable=true
*  gnome-shell-extensions gnome-tweaks
很多插件是以 gnome-shell-extensions 或依赖 gnome-shell-extensions 如 https://github.com/k0kubun/xremap
故先要安装 gnome-shell-extensions
#+begin_src sh
sudo apt install gnome-shell-extensions  chrome-gnome-shell
#+end_src
** gnome-tweaks
1. 禁用左右 cmd（win）键 单按时的行为
   https://linux.how2shout.com/how-to-disable-super-or-win-key-in-ubuntu-20-04-or-18-04/
    sudo apt install gnome-tweaks
    gnome-tweaks
* xremap
https://github.com/k0kubun/xremap
https://github.com/k0kubun/xremap/blob/master/example/config.yml

* toggle App
将以下脚本绑定到某快捷键上即可
#+begin_src sh
#!/bin/bash
# Check if Emacs is running
if [[ $(xdotool search --onlyvisible --name "emacs") ]]; then
    # Check if the current window is Emacs
    active_window=$(xdotool getactivewindow)
    emacs_window=$(xdotool search --onlyvisible --name "emacs")
    if [[ $active_window == $emacs_window ]]; then
        # Hide Emacs if it is the active window
        xdotool windowminimize $active_window
    else
        # Bring Emacs to front if it is not the active window
        xdotool windowactivate $emacs_window
    fi
else
    # Launch Emacs if it is not running
    emacs &
fi

#+end_src

#+begin_src sh
#!/bin/bash
# Check if terminal is running
if [[ $(xdotool search --onlyvisible --name "终端") ]]; then
    # Check if the current window is Emacs
    active_window=$(xdotool getactivewindow)
    emacs_window=$(xdotool search --onlyvisible --name "终端")
    if [[ $active_window == $emacs_window ]]; then
        # Hide Emacs if it is the active window
        xdotool windowminimize $active_window
    else
        # Bring Emacs to front if it is not the active window
        xdotool windowactivate $emacs_window
    fi
else
    # Launch Emacs if it is not running
     gnome-terminal&
fi
#+end_src
* spacebar 作为 mac 的 cmd 或者 windows 的 win 来用
https://github.com/alols/xcape/issues/122
https://emacsredux.com/blog/2020/07/05/remap-enter-to-control-in-gnu-linux-2020-edition/

#+begin_src sh
sudo apt install libudev-dev libyaml-cpp-dev libevdev-dev cmake gcc g++ libboost-all-dev libinput-tools
mkdir src && cd src
git clone https://gitlab.com/interception/linux/tools
# build and install the interception framework
cd tools;mkdir build; cd build; cmake ..; make;sudo make install; cd ../..
# build the dual-function-keys plugin
git clone https://gitlab.com/interception/linux/plugins/dual-function-keys
cd dual-function-keys; make && sudo make install
#+end_src

#+begin_src sh
ln -s dual-function-keys.yaml ~/dual-function-keys.yaml
#+end_src

* 交换 lctrl 与 lwin (不再推荐使用 xorg 有效 wayland 无效,推荐使用 dual-function-keys.yaml)
# https://wiki.archlinux.org/title/Xorg/Keyboard_configuration
# setxkbmap 的配置 要在 xmodmap 之后，且不再推荐使用 xmodmap
# 交换 lctrl lwin
#
setxkbmap -option "ctrl:swap_lwin_lctl"


* spacebar 作为 mac 的 cmd 或者 windows 的 win 来用(不再推荐使用 xorg 有效 wayland 无效,推荐使用 dual-function-keys.yaml)
#+begin_src sh
#  xev 可查看每个按键的 keycode
# https://github.com/alols/xcape
# https://www.cnblogs.com/yinheyi/p/10146900.html
xmodmap -e "keycode 65 = Super_L NoSymbol Super_L"
# Map space to an unused keycode (to keep it around for xcape to use).
xmodmap -e "keycode any = space"
# Finally use xcape to cause the space bar to generate a space when tapped.
# 按 xcape 的 readme xcape 最好放在所有 xmodmap 之后
xcape -e "Super_L=space"
#+end_src
* ctrl 单独按下作为 escape(不再推荐使用 xorg 有效 wayland 无效 ，推荐使用 dual-function-keys.yaml)
#+begin_src sh
xcape -e 'Control_L=Escape'
#+end_src
